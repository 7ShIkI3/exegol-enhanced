#!/usr/bin/env python3

"""
Crypto Analyzer - Exegol Enhanced
Developed with AI assistance for cryptographic analysis and CTF challenges
Version: 1.0.0

Features:
- Hash identification and cracking
- Classical cipher analysis
- Encoding/decoding utilities
- Frequency analysis
- Pattern recognition
- CTF-focused tools
"""

import argparse
import hashlib
import base64
import binascii
import string
import re
import json
import os
import sys
from collections import Counter
from itertools import cycle
import requests
from pathlib import Path

# Colors for terminal output
class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    END = '\033[0m'

class CryptoAnalyzer:
    def __init__(self):
        self.common_passwords = [
            'password', '123456', 'admin', 'root', 'test', 'guest',
            'user', 'login', 'pass', 'secret', 'qwerty', 'abc123',
            'password123', 'admin123', 'letmein', 'welcome', 'monkey',
            'dragon', 'master', 'shadow', 'football', 'baseball'
        ]
        
        # Common hash patterns
        self.hash_patterns = {
            32: ['MD5', 'NTLM'],
            40: ['SHA1'],
            56: ['SHA224'],
            64: ['SHA256'],
            96: ['SHA384'],
            128: ['SHA512'],
            16: ['MD4 (hex)', 'CRC64'],
            8: ['CRC32'],
            13: ['DES (crypt)'],
            34: ['MD5 (with salt)'],
            37: ['SHA1 (with salt)']
        }
        
        # Frequency analysis for English
        self.english_freq = {
            'E': 12.7, 'T': 9.1, 'A': 8.2, 'O': 7.5, 'I': 7.0, 'N': 6.7,
            'S': 6.3, 'H': 6.1, 'R': 6.0, 'D': 4.3, 'L': 4.0, 'C': 2.8,
            'U': 2.8, 'M': 2.4, 'W': 2.4, 'F': 2.2, 'G': 2.0, 'Y': 2.0,
            'P': 1.9, 'B': 1.3, 'V': 1.0, 'K': 0.8, 'J': 0.15, 'X': 0.15,
            'Q': 0.10, 'Z': 0.07
        }

    def print_banner(self):
        """Print application banner"""
        banner = f"""
{Colors.PURPLE}╔══════════════════════════════════════════════════════════════╗
║                    CRYPTO ANALYZER                          ║
║                     Exegol Enhanced                         ║
║                                                              ║
║              🔐 Advanced Cryptographic Analysis 🔐          ║
╚══════════════════════════════════════════════════════════════╝{Colors.END}
"""
        print(banner)

    def print_info(self, message):
        print(f"{Colors.BLUE}[INFO]{Colors.END} {message}")

    def print_success(self, message):
        print(f"{Colors.GREEN}[SUCCESS]{Colors.END} {message}")

    def print_warning(self, message):
        print(f"{Colors.YELLOW}[WARNING]{Colors.END} {message}")

    def print_error(self, message):
        print(f"{Colors.RED}[ERROR]{Colors.END} {message}")

    def print_result(self, title, content):
        print(f"\n{Colors.CYAN}=== {title} ==={Colors.END}")
        print(content)

    def identify_hash(self, hash_string):
        """Identify hash type based on length and patterns"""
        hash_string = hash_string.strip()
        length = len(hash_string)
        
        self.print_result("HASH IDENTIFICATION", f"Input: {hash_string}")
        self.print_info(f"Length: {length} characters")
        
        # Check if it's hexadecimal
        is_hex = all(c in '0123456789abcdefABCDEF' for c in hash_string)
        
        if is_hex:
            self.print_success("Format: Hexadecimal")
            if length in self.hash_patterns:
                possible_types = self.hash_patterns[length]
                self.print_info(f"Possible hash types: {', '.join(possible_types)}")
                return possible_types
            else:
                self.print_warning("Unknown hash length")
        else:
            # Check for base64 patterns
            if self.is_base64(hash_string):
                self.print_info("Possible Base64 encoded hash")
                try:
                    decoded = base64.b64decode(hash_string)
                    self.print_info(f"Decoded length: {len(decoded)} bytes")
                except:
                    pass
            
            # Check for bcrypt, scrypt, etc.
            if hash_string.startswith('$'):
                parts = hash_string.split('$')
                if len(parts) >= 3:
                    hash_type = parts[1]
                    type_map = {
                        '1': 'MD5 (crypt)',
                        '2a': 'Blowfish (bcrypt)',
                        '2b': 'Blowfish (bcrypt)',
                        '2y': 'Blowfish (bcrypt)',
                        '5': 'SHA-256 (crypt)',
                        '6': 'SHA-512 (crypt)'
                    }
                    if hash_type in type_map:
                        self.print_success(f"Identified: {type_map[hash_type]}")
                        return [type_map[hash_type]]
        
        return []

    def is_base64(self, s):
        """Check if string is valid base64"""
        try:
            if isinstance(s, str):
                s_bytes = bytes(s, 'ascii')
            else:
                s_bytes = s
            return base64.b64encode(base64.b64decode(s_bytes)) == s_bytes
        except Exception:
            return False

    def crack_hash(self, hash_string, wordlist=None):
        """Attempt to crack hash using common passwords"""
        self.print_result("HASH CRACKING", f"Attempting to crack: {hash_string}")
        
        # Use provided wordlist or common passwords
        passwords = self.common_passwords
        if wordlist and os.path.exists(wordlist):
            try:
                with open(wordlist, 'r', encoding='utf-8', errors='ignore') as f:
                    passwords = [line.strip() for line in f if line.strip()]
                self.print_info(f"Loaded {len(passwords)} passwords from wordlist")
            except Exception as e:
                self.print_warning(f"Could not load wordlist: {e}")
        
        # Try different hash algorithms
        hash_funcs = {
            'MD5': hashlib.md5,
            'SHA1': hashlib.sha1,
            'SHA224': hashlib.sha224,
            'SHA256': hashlib.sha256,
            'SHA384': hashlib.sha384,
            'SHA512': hashlib.sha512
        }
        
        hash_string = hash_string.lower().strip()
        
        for password in passwords:
            for hash_name, hash_func in hash_funcs.items():
                try:
                    computed_hash = hash_func(password.encode()).hexdigest()
                    if computed_hash == hash_string:
                        self.print_success(f"CRACKED! Password: '{password}' (Algorithm: {hash_name})")
                        return password, hash_name
                except:
                    continue
        
        self.print_warning("Hash not cracked with available wordlist")
        return None, None

    def analyze_frequency(self, text):
        """Perform frequency analysis on text"""
        self.print_result("FREQUENCY ANALYSIS", f"Analyzing text of length {len(text)}")
        
        # Count characters
        text_upper = text.upper()
        char_count = Counter(c for c in text_upper if c.isalpha())
        total_chars = sum(char_count.values())
        
        if total_chars == 0:
            self.print_warning("No alphabetic characters found")
            return
        
        # Calculate frequencies
        frequencies = {}
        for char, count in char_count.items():
            frequencies[char] = (count / total_chars) * 100
        
        # Sort by frequency
        sorted_freq = sorted(frequencies.items(), key=lambda x: x[1], reverse=True)
        
        print(f"\n{Colors.YELLOW}Character Frequencies:{Colors.END}")
        print("Char | Count | Freq% | Expected% (English)")
        print("-" * 45)
        
        for char, freq in sorted_freq[:10]:  # Top 10
            expected = self.english_freq.get(char, 0)
            print(f"  {char}  |  {char_count[char]:3d}  | {freq:5.1f} | {expected:5.1f}")
        
        # Calculate chi-squared for English
        chi_squared = 0
        for char in string.ascii_uppercase:
            observed = frequencies.get(char, 0)
            expected = self.english_freq.get(char, 0)
            if expected > 0:
                chi_squared += ((observed - expected) ** 2) / expected
        
        self.print_info(f"Chi-squared value: {chi_squared:.2f}")
        if chi_squared < 50:
            self.print_success("Text appears to be English-like")
        else:
            self.print_warning("Text does not appear to be English")
        
        return frequencies

    def caesar_cipher_analysis(self, ciphertext):
        """Analyze Caesar cipher with all possible shifts"""
        self.print_result("CAESAR CIPHER ANALYSIS", f"Analyzing: {ciphertext[:50]}...")
        
        results = []
        
        for shift in range(26):
            decrypted = ""
            for char in ciphertext:
                if char.isalpha():
                    ascii_offset = 65 if char.isupper() else 97
                    decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)
                else:
                    decrypted += char
            
            # Simple scoring based on common English words
            score = self.score_english_text(decrypted)
            results.append((shift, decrypted, score))
        
        # Sort by score
        results.sort(key=lambda x: x[2], reverse=True)
        
        print(f"\n{Colors.YELLOW}Top Caesar cipher candidates:{Colors.END}")
        for i, (shift, text, score) in enumerate(results[:5]):
            print(f"Shift {shift:2d} (Score: {score:3d}): {text[:80]}...")
            if i == 0:
                self.print_success(f"Best candidate: Shift {shift}")
        
        return results[0] if results else None

    def score_english_text(self, text):
        """Score text based on English language characteristics"""
        common_words = [
            'THE', 'AND', 'FOR', 'ARE', 'BUT', 'NOT', 'YOU', 'ALL', 'CAN', 'HER',
            'WAS', 'ONE', 'OUR', 'HAD', 'BY', 'WORD', 'WHAT', 'SAID', 'EACH', 'WHICH'
        ]
        
        text_upper = text.upper()
        score = 0
        
        # Score based on common words
        for word in common_words:
            score += text_upper.count(word) * len(word)
        
        # Score based on letter frequency
        for char in text_upper:
            if char in self.english_freq:
                score += 1
        
        return score

    def vigenere_analysis(self, ciphertext, key_length=None):
        """Analyze Vigenère cipher"""
        self.print_result("VIGENÈRE CIPHER ANALYSIS", f"Analyzing: {ciphertext[:50]}...")
        
        # Remove non-alphabetic characters
        clean_text = ''.join(c.upper() for c in ciphertext if c.isalpha())
        
        if key_length:
            key_lengths = [key_length]
        else:
            # Try to determine key length using Index of Coincidence
            key_lengths = self.find_key_lengths(clean_text)
        
        best_result = None
        best_score = 0
        
        for kl in key_lengths[:3]:  # Try top 3 key lengths
            self.print_info(f"Trying key length: {kl}")
            
            # Split text into groups based on key length
            groups = [''] * kl
            for i, char in enumerate(clean_text):
                groups[i % kl] += char
            
            # Analyze each group as Caesar cipher
            key = ''
            decrypted_groups = []
            
            for group in groups:
                if group:
                    # Find best Caesar shift for this group
                    best_shift = 0
                    best_group_score = 0
                    
                    for shift in range(26):
                        decrypted_group = ''
                        for char in group:
                            decrypted_group += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))
                        
                        score = self.score_english_text(decrypted_group)
                        if score > best_group_score:
                            best_group_score = score
                            best_shift = shift
                    
                    key += chr(best_shift + ord('A'))
                    decrypted_groups.append(''.join(
                        chr((ord(char) - ord('A') - best_shift) % 26 + ord('A'))
                        for char in group
                    ))
            
            # Reconstruct decrypted text
            decrypted = ''
            group_indices = [0] * kl
            
            for i in range(len(clean_text)):
                group_idx = i % kl
                if group_indices[group_idx] < len(decrypted_groups[group_idx]):
                    decrypted += decrypted_groups[group_idx][group_indices[group_idx]]
                    group_indices[group_idx] += 1
            
            score = self.score_english_text(decrypted)
            
            if score > best_score:
                best_score = score
                best_result = (key, decrypted, score)
            
            print(f"Key: {key}, Score: {score}")
            print(f"Decrypted: {decrypted[:80]}...")
        
        if best_result:
            key, decrypted, score = best_result
            self.print_success(f"Best key found: {key}")
            self.print_success(f"Decrypted text: {decrypted}")
        
        return best_result

    def find_key_lengths(self, ciphertext):
        """Find likely key lengths using Index of Coincidence"""
        ic_values = []
        
        for key_length in range(1, min(21, len(ciphertext) // 4)):
            groups = [''] * key_length
            for i, char in enumerate(ciphertext):
                groups[i % key_length] += char
            
            avg_ic = 0
            for group in groups:
                if len(group) > 1:
                    ic = self.calculate_ic(group)
                    avg_ic += ic
            
            avg_ic /= key_length
            ic_values.append((key_length, avg_ic))
        
        # Sort by IC (higher IC suggests correct key length for Vigenère)
        ic_values.sort(key=lambda x: x[1], reverse=True)
        
        return [kl for kl, ic in ic_values]

    def calculate_ic(self, text):
        """Calculate Index of Coincidence"""
        n = len(text)
        if n <= 1:
            return 0
        
        freq_sum = sum(text.count(c) * (text.count(c) - 1) for c in set(text))
        return freq_sum / (n * (n - 1))

    def decode_common_encodings(self, data):
        """Try to decode common encodings"""
        self.print_result("ENCODING ANALYSIS", f"Analyzing: {data[:50]}...")
        
        results = {}
        
        # Base64
        try:
            if self.is_base64(data):
                decoded = base64.b64decode(data).decode('utf-8', errors='ignore')
                results['Base64'] = decoded
                self.print_success(f"Base64 decoded: {decoded[:80]}...")
        except:
            pass
        
        # URL encoding
        try:
            import urllib.parse
            url_decoded = urllib.parse.unquote(data)
            if url_decoded != data:
                results['URL'] = url_decoded
                self.print_success(f"URL decoded: {url_decoded[:80]}...")
        except:
            pass
        
        # Hex
        try:
            if all(c in '0123456789abcdefABCDEF' for c in data.replace(' ', '')):
                hex_decoded = bytes.fromhex(data.replace(' ', '')).decode('utf-8', errors='ignore')
                results['Hex'] = hex_decoded
                self.print_success(f"Hex decoded: {hex_decoded[:80]}...")
        except:
            pass
        
        # Binary
        try:
            if all(c in '01 ' for c in data):
                binary_data = data.replace(' ', '')
                if len(binary_data) % 8 == 0:
                    binary_decoded = ''.join(
                        chr(int(binary_data[i:i+8], 2))
                        for i in range(0, len(binary_data), 8)
                    )
                    results['Binary'] = binary_decoded
                    self.print_success(f"Binary decoded: {binary_decoded[:80]}...")
        except:
            pass
        
        # ROT13
        try:
            rot13_decoded = data.encode().decode('rot13')
            results['ROT13'] = rot13_decoded
            self.print_success(f"ROT13 decoded: {rot13_decoded[:80]}...")
        except:
            pass
        
        return results

    def analyze_patterns(self, data):
        """Analyze patterns in the data"""
        self.print_result("PATTERN ANALYSIS", f"Analyzing patterns in data")
        
        # Length analysis
        self.print_info(f"Data length: {len(data)}")
        
        # Character set analysis
        char_types = {
            'uppercase': sum(1 for c in data if c.isupper()),
            'lowercase': sum(1 for c in data if c.islower()),
            'digits': sum(1 for c in data if c.isdigit()),
            'special': sum(1 for c in data if not c.isalnum()),
            'spaces': data.count(' ')
        }
        
        print(f"\n{Colors.YELLOW}Character composition:{Colors.END}")
        for char_type, count in char_types.items():
            percentage = (count / len(data)) * 100 if len(data) > 0 else 0
            print(f"{char_type.capitalize()}: {count} ({percentage:.1f}%)")
        
        # Repeating patterns
        patterns = {}
        for length in range(2, min(10, len(data) // 2)):
            for i in range(len(data) - length + 1):
                pattern = data[i:i+length]
                if pattern in patterns:
                    patterns[pattern] += 1
                else:
                    patterns[pattern] = 1
        
        # Show most common patterns
        common_patterns = [(p, c) for p, c in patterns.items() if c > 1]
        if common_patterns:
            common_patterns.sort(key=lambda x: x[1], reverse=True)
            print(f"\n{Colors.YELLOW}Repeating patterns:{Colors.END}")
            for pattern, count in common_patterns[:5]:
                print(f"'{pattern}': {count} times")

def main():
    parser = argparse.ArgumentParser(
        description='Crypto Analyzer - Exegol Enhanced',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --hash 5d41402abc4b2a76b9719d911017c592
  %(prog)s --crack 5d41402abc4b2a76b9719d911017c592 --wordlist passwords.txt
  %(prog)s --caesar "KHOOR ZRUOG"
  %(prog)s --vigenere "LXFOPVEFRNHR" --key-length 3
  %(prog)s --frequency "This is a sample text for analysis"
  %(prog)s --decode "SGVsbG8gV29ybGQ="
  %(prog)s --analyze "ABCDEFABCDEFABCDEF"
        """
    )
    
    # Analysis modes
    parser.add_argument('--hash', help='Identify hash type')
    parser.add_argument('--crack', help='Attempt to crack hash')
    parser.add_argument('--wordlist', help='Wordlist file for hash cracking')
    parser.add_argument('--caesar', help='Analyze Caesar cipher')
    parser.add_argument('--vigenere', help='Analyze Vigenère cipher')
    parser.add_argument('--key-length', type=int, help='Key length for Vigenère analysis')
    parser.add_argument('--frequency', help='Perform frequency analysis')
    parser.add_argument('--decode', help='Try common encoding schemes')
    parser.add_argument('--analyze', help='Analyze patterns in data')
    parser.add_argument('--file', help='Read input from file')
    
    args = parser.parse_args()
    
    # Create analyzer instance
    analyzer = CryptoAnalyzer()
    analyzer.print_banner()
    
    # Read from file if specified
    if args.file:
        try:
            with open(args.file, 'r', encoding='utf-8', errors='ignore') as f:
                file_content = f.read().strip()
            analyzer.print_info(f"Loaded data from file: {args.file}")
        except Exception as e:
            analyzer.print_error(f"Could not read file: {e}")
            sys.exit(1)
    
    # Execute requested analysis
    if args.hash:
        data = file_content if args.file else args.hash
        analyzer.identify_hash(data)
    
    elif args.crack:
        data = file_content if args.file else args.crack
        analyzer.crack_hash(data, args.wordlist)
    
    elif args.caesar:
        data = file_content if args.file else args.caesar
        analyzer.caesar_cipher_analysis(data)
    
    elif args.vigenere:
        data = file_content if args.file else args.vigenere
        analyzer.vigenere_analysis(data, args.key_length)
    
    elif args.frequency:
        data = file_content if args.file else args.frequency
        analyzer.analyze_frequency(data)
    
    elif args.decode:
        data = file_content if args.file else args.decode
        analyzer.decode_common_encodings(data)
    
    elif args.analyze:
        data = file_content if args.file else args.analyze
        analyzer.analyze_patterns(data)
    
    else:
        # Interactive mode
        analyzer.print_info("No specific analysis requested. Use --help for options.")
        analyzer.print_info("Interactive mode not implemented yet.")

if __name__ == '__main__':
    main()
